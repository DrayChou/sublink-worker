# Sublink Worker 缓存功能开发记录

> 文档生成时间: 2026-01-15
> 原始开发时间: 2025-11-11

---

## 1. 背景与问题

### 1.1 核心问题

订阅链接具有时间限制，第一次请求成功后，后续请求可能返回错误（如 403、过期等），导致用户得到空配置。

**用户原话:**
> 收到链接之后，下载链接里的内容之后有没有进行缓存？因为现在很多链接都是有时间限制的，第一轮请求结束之后，后面再请求就会返回错误，但是不能就直接返回空出去啊，所以这里就需要拿之前成功的那次的结果来用。

### 1.2 目标

- 实现智能缓存机制，链接失效时自动降级到缓存数据
- 减少重复下载请求，提升性能
- 控制成本，减少外部请求次数

---

## 2. 实现的功能

### 2.1 智能缓存系统 (`src/cacheManager.js`)

**核心数据结构:**
```javascript
{
  content: "下载的原始内容",
  timestamp: 1234567890,
  successCount: 5,     // 成功次数
  failCount: 2,        // 失败次数
  lastSuccess: 1234567890,
  ttl: 3600           // 动态TTL（基于成功率动态调整）
}
```

**缓存键设计:**
```javascript
const cacheKey = `subcache:${hashUrl(url)}`;
```

### 2.2 处理流程

```
fetchWithCache(url, userAgent)
  ├── 尝试实时下载
  ├── 成功 → 更新缓存内容、成功率、TTL
  └── 失败 → 检查是否有可用缓存
              ├── 有缓存 → 降级返回缓存内容
              └── 无缓存 → 返回错误
```

### 2.3 动态TTL策略

- **高成功率**: 延长TTL（缓存更久）
- **低成功率**: 缩短TTL（更快刷新）
- **失败后**: 保持缓存供降级使用

### 2.4 缓存管理功能

- 成功/失败计数追踪
- 自动缓存过期
- 缓存统计接口 (`/cache-stats`)

---

## 3. 重试机制

### 3.1 多级重试策略

**3次重试尝试**，每次使用不同的 User-Agent:

| 尝试次数 | User-Agent | Headers |
|---------|------------|---------|
| 第1次 | FlClash 真实请求头 | 完整真实 headers |
| 第2次 | curl/7.88.1 | 标准浏览器 headers |
| 第3次 | 随机轮换 | 防缓存 headers |

### 3.2 真实请求头集成

**来自实际 FlClash 请求的完整 headers:**
```javascript
{
    "accept-encoding": "gzip, br",
    "connection": "Keep-Alive",
    "user-agent": "FlClash/v0.8.74 clash-verge Platform/windows",
    "x-forwarded-proto": "https",
    "x-real-ip": "47.91.20.160"
}
```

**新增的真实 User-Agent 列表:**
- `FlClash/v0.8.74 clash-verge Platform/windows` (来自实际请求)
- `clash-verge/v1.7.4` (最新版本)
- `ShadowsocksX-NG/1.8.2` (macOS客户端)

### 3.3 修复的问题

1. **参数传递错误**: 修复 `fetchWithSubscriptionCache` 直接替换 headers 的问题
2. **Headers 合并**: 正确合并原始 headers 和轮换的 User-Agent

**修复前的问题:**
```javascript
// ❌ 完全替换原始headers
fetchWithSubscriptionCache(url, {
    headers: { 'User-Agent': userAgent }
});
```

**修复后的解决方案:**
```javascript
// ✅ 保留原始headers并轮换User-Agent
const mergedHeaders = new Headers(fetchOptions.headers || {});
mergedHeaders.set('User-Agent', userAgent);
```

---

## 4. 代码变更

### 4.1 新增文件

| 文件 | 说明 |
|------|------|
| `src/cacheManager.js` | 缓存管理器核心逻辑 |

### 4.2 修改文件

| 文件 | 修改内容 |
|------|---------|
| `src/ProxyParsers.js` | 添加缓存下载支持 |
| `src/index.js` | 初始化缓存管理器 |
| `src/utils.js` | 添加 `hashString` 工具函数 |

### 4.3 Git 提交记录

| 提交 | 描述 |
|------|------|
| `6197823` | feat(cache): add intelligent subscription content caching system |
| `47a8417` | log |
| `7a4c706` | feat(cache): add retry mechanism with rotating User-Agents |
| `1a4c02e` | fix(cache): properly implement retry mechanism with correct headers |
| `fc6c17a` | enhance(cache): implement advanced retry strategies for blocked subscriptions |
| `49046b2` | enhance(cache): add real-world client headers from actual requests |

---

## 5. 测试遇到的问题

### 5.1 重试机制未生效

**日志显示:**
```
开始重试下载: https://43.139.213.75:9000/..., 最大重试次数: 3
尝试下载 (第1次): ..., User-Agent: curl/7.88.1
下载失败 (第1次): ...
```

**原因:** 参数传递错误，headers 被完全替换而非合并

### 5.2 部分订阅源持续失败

某些订阅源即使重试也无法成功获取，需要:
- 使用更真实的请求头
- 更换 User-Agent 轮换策略

---

## 6. 设计决策记录

### 6.1 为什么选择 KV 存储?

- Cloudflare Workers 原生支持
- 分布式访问，低延迟
- 自动同步全球节点

### 6.2 缓存降级策略

| 场景 | 处理方式 |
|------|---------|
| 下载成功 | 更新缓存内容和 TTL |
| 下载失败 + 有缓存 | 返回缓存内容（标记为过期） |
| 下载失败 + 无缓存 | 返回错误 |

### 6.3 User-Agent 轮换

使用常用代理工具的 User-Agent，降低被识别为爬虫的概率:
- curl
- Clash for Windows
- Surge
- Quantumult X

---

## 7. 注意事项

### 7.1 安全检查

✅ 已验证: 没有把获取的内容发送给第三方服务

### 7.2 代码质量

✅ 已验证:
- 无冗余代码
- 必要、优雅、高效
- 符合项目现有代码风格

### 7.3 已知限制

- 缓存仅在首次成功下载后才有效
- 对于持续失败的订阅源，缓存无法提供帮助
- 需要平衡缓存 TTL 和数据新鲜度

---

## 8. 后续优化方向

1. **更智能的 TTL 调整**: 基于失败率动态计算
2. **缓存预热**: 定期刷新热门订阅
3. **多级缓存**: 本地 + KV 双重缓存
4. **失败告警**: 监控异常订阅源

---

## 9. 相关链接

- 项目地址: https://github.com/DrayChou/sublink-worker
- 原始仓库: https://github.com/Golevka2001/sublink-worker
- Cloudflare KV: https://developers.cloudflare.com/workers/runtime-apis/kv/
